import streamlit as st
import requests
import pandas as pd
import os
from pathlib import Path

BACKEND_URL = "http://127.0.0.1:8000"

st.set_page_config(page_title="Login Demo", layout="centered")

# Session state
if "login_message" not in st.session_state:
    st.session_state.login_message = ""
if "logged_in" not in st.session_state:
    st.session_state.logged_in = False

# Sidebar Navigation
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to:",
    ["Login", "Dashboard", "Content Moderation", "Test Insights"],
    index=["Login", "Dashboard", "Content Moderation", "Test Insights"].index(
        st.session_state.get("page", "Login")
    )
)

# LOGIN PAGE
if page == "Login":
    if not st.session_state.logged_in:
        st.title("üîê Login Page")

        with st.form("login_form"):
            username = st.text_input("Username", key="username", label_visibility="visible")
            password = st.text_input("Password", type="password", key="password", label_visibility="visible")
            submitted = st.form_submit_button("Login")

            if submitted:
                if not username:
                    st.session_state.login_message = "Username is required"
                elif not password:
                    st.session_state.login_message = "Password is required"
                elif username == "admin" and password == "password123":
                    st.session_state.logged_in = True
                    st.session_state.login_message = f"Welcome, {username}"
                    st.session_state["page"] = "Dashboard"
                    st.rerun()
                else:
                    st.session_state.login_message = "Invalid credentials"

        # Element for Playwright to read login result
        st.markdown(
            f"<div id='login-result'>{st.session_state.login_message}</div>",
            unsafe_allow_html=True
        )

    else:
        st.success(st.session_state.login_message)
        st.sidebar.success("‚úÖ You are logged in!")

# DASHBOARD
elif page == "Dashboard":
    if st.session_state.logged_in:
        st.title("üìä Dashboard Overview")

        if st.button("Logout"):
            st.session_state.logged_in = False
            st.session_state.login_message = ""
            st.rerun()

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Active Users", "1,245", "+58 today")
        with col2:
            st.metric("Revenue", "$12.4K", "‚Üë 12%")
        with col3:
            st.metric("Server Status", "‚úÖ Online")

        st.divider()
        st.write("### Recent Activity")
        st.table({
            "User": ["alice", "bob", "charlie"],
            "Action": ["Login", "Upload File", "Logout"],
            "Time": ["10:21 AM", "11:05 AM", "11:47 AM"]
        })

        st.divider()
        st.write("### Performance Chart")
        st.line_chart({
            "Month": ["Jan", "Feb", "Mar", "Apr", "May"],
            "Sales": [120, 150, 180, 90, 200],
        })
    else:
        st.warning("‚ö†Ô∏è Please log in first!")

# CONTENT MODERATION
elif page == "Content Moderation":
    st.title("üõ°Ô∏è Content Moderation with Detoxify")

    user_input = st.text_area("Enter text to check for toxicity:")
    if st.button("Moderate Text"):
        if user_input.strip():
            try:
                response = requests.post(f"{BACKEND_URL}/api/moderate", json={"text": user_input})
                if response.status_code == 200:
                    result = response.json()
                    if result.get("toxicity") == "toxic":
                        st.error("üö® This text is **Toxic**!")
                    else:
                        st.success("‚úÖ This text is **Safe**.")
                    st.json(result)
                else:
                    st.error(f"Server error: {response.status_code}")
            except Exception as e:
                st.error(f"Error: {e}")
        else:
            st.warning("Please enter some text before moderating.")

# TEST INSIGHTS PAGE
elif page == "Test Insights":
    import re
    import pandas as pd
    from fuzzywuzzy import fuzz, process
    import os
    from pathlib import Path
    import streamlit as st

    st.title("üß© Unified Test Insights Dashboard")
    st.caption("Automatically generated by analyzing test source files across all tools.")

    # 1Ô∏è‚É£ Correct mapping: tool_label -> file_path
    BASE_DIR = Path(__file__).resolve().parent

    TEST_PATHS = {
        "Pytest (Login)": BASE_DIR / "tests/api/test_login.py",
        "Pytest (Moderation)": BASE_DIR / "tests/api/test_moderate.py",
        "Postman": BASE_DIR / "tests/postman/collection.json",
        "Playwright": BASE_DIR / "tests/ui/test_ui_login.py",
        "Groq": BASE_DIR / "tests/generated/openapi_stubs_groq.py",
        "Ollama": BASE_DIR / "tests/generated/openapi_stubs_ollama.py"
    }

    # 2Ô∏è‚É£ Extract test names from each file
    def extract_test_names(file_path):
        tests = []
        try:
            if file_path.endswith(".json"):
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read().lower()
                matches = re.findall(r'"name":\s*"([^"]+)"', content)
                for m in matches:
                    if any(k in m for k in ["login", "moderate", "protected"]):
                        tests.append(m.strip())
            else:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
                matches = re.findall(r"def\s+(test_[a-zA-Z0-9_]+)", content)
                tests.extend(matches)
        except Exception as e:
            st.warning(f"Could not parse {file_path}: {e}")
        return tests

    # 3Ô∏è‚É£ Read tests from all files
    all_tests = []
    for label, path in TEST_PATHS.items():
        if not path.exists():
            st.warning(f"‚ö†Ô∏è Missing file: {path}")
            continue
        for t in extract_test_names(str(path)):
            all_tests.append({"Test": t, "Tool": label})

    if not all_tests:
        st.error("No test files found or parsed.")
        st.stop()

    df = pd.DataFrame(all_tests)

    # 4Ô∏è‚É£ Normalize test names
    def normalize_name(name):
        name = name.replace("test_", "").replace("_", " ").strip().title()
        name = name.replace("Valid", "Success").replace("Wrong", "Failure (Wrong Credentials)")
        name = name.replace("Fields", "Invalid Input / Fields")
        # Fix duplicate pattern like "Failure (Failure (Wrong Credentials) Credentials)"
        name = re.sub(r"Failure\s*\(Failure\s*\(Wrong Credentials\)\s*Credentials\)", "Failure (Wrong Credentials)", name)
        name = name.replace("Ollama", "").replace("Groq", "").strip()
        return name

    df["Readable"] = df["Test"].apply(normalize_name)

    # 5Ô∏è‚É£ Fuzzy-merge similar tests (threshold 80 instead of 85)
    unique_names, canonical_map = [], {}
    for name in df["Readable"]:
        match = process.extractOne(name, unique_names, scorer=fuzz.token_sort_ratio)
        if match and match[1] > 80:
            canonical_map[name] = match[0]
        else:
            unique_names.append(name)
            canonical_map[name] = name
    df["Canonical"] = df["Readable"].map(canonical_map)

    # 6Ô∏è‚É£ Merge tools for same test
    merged = (
        df.groupby("Canonical")
        .agg({"Tool": lambda x: ", ".join(sorted(set(x)))})
        .reset_index()
    )

    # 7Ô∏è‚É£ Determine correct area/layer
    def get_area(name: str):
        n = name.lower()

        # 1Ô∏è‚É£ Backend APIs always take priority
        if any(k in n for k in ["login", "protected", "moderate"]):
            return "Backend (Auth/API)" if "moderate" not in n else "Backend (Toxicity / Model)"

        # 2Ô∏è‚É£ AI analysis or failure diagnostics
        if any(k in n for k in ["ai failure", "analyzer", "groq", "ollama"]) and not any(
            k in n for k in ["login", "protected", "moderate"]
        ):
            return "Cloud AI (Groq)" if "groq" in n else "Local AI (Ollama)"

        # 3Ô∏è‚É£ Frontend UI tests
        if any(k in n for k in ["ui", "page", "logout", "navigation"]):
            return "Frontend (UI)"

        # 4Ô∏è‚É£ Default catch-all
        return "Misc"

    merged["Layer / Area"] = merged["Canonical"].apply(get_area)
    merged["Status"] = "‚úÖ Passed"
    merged["Tools That Ran This Test"] = merged["Tool"].apply(
        lambda t: "  ".join([f"‚úÖ {x}" for x in t.split(", ")])
    )
    merged = merged.drop(columns=["Tool"])

    # 8Ô∏è‚É£ Final formatting
    merged.insert(0, "Index", range(1, len(merged) + 1))
    merged = merged[["Index", "Canonical", "Layer / Area", "Tools That Ran This Test", "Status"]]
    merged.columns = ["Index", "Test Name", "Layer / Area", "Tools That Ran This Test", "Status"]

    # Save CSV for record
    merged.to_csv("final_unified_tests.csv", index=False)

    # 9Ô∏è‚É£ Display metrics at the top
    total_tests = len(merged)
    passed_tests = (merged["Status"] == "‚úÖ Passed").sum()
    failed_tests = (merged["Status"] == "‚ùå Failed").sum()

    col1, col2, col3 = st.columns([1, 1, 1])
    with col1:
        st.metric("üìä Total Tests", total_tests)
    with col2:
        st.metric("‚úÖ Passed", passed_tests)
    with col3:
        st.metric("‚ùå Failed", failed_tests)

    st.divider()

    # üîπ Display main test table without horizontal scrolling
    st.subheader("üìã Consolidated Test Overview")

    # Convert DataFrame to clean HTML table
    html_table = merged.to_html(
        index=False,
        classes="styled-table",
        border=0,
        escape=False
    )

    # Custom CSS for auto-fit, wrapping, and vertical scroll only
    st.markdown("""
    <style>
        .styled-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            table-layout: fixed;        /* ‚úÖ Ensures proper column fitting */
            word-wrap: break-word;      /* ‚úÖ Allows wrapping instead of scrolling */
        }
        .styled-table thead tr {
            background-color: #009879;
            color: #ffffff;
            text-align: left;
        }
        .styled-table th, .styled-table td {
            padding: 8px 10px;
            border: 1px solid #ddd;
            white-space: normal;
            vertical-align: top;
        }
        .styled-table tbody tr:nth-child(even) { background-color: #f3f3f3; }
        .styled-table tbody tr:hover { background-color: #e0f7fa; }
        .report-container {
            max-height: 600px;           /* ‚úÖ Enables vertical scrolling */
            overflow-y: auto;
            overflow-x: hidden;          /* ‚úÖ Disable horizontal scrolling */
        }
    </style>
    """, unsafe_allow_html=True)

    st.markdown(f"<div class='report-container'>{html_table}</div>", unsafe_allow_html=True)
    # -----------------------
    # üîç Detailed Test Insight Section
    # -----------------------

    st.divider()
    st.subheader("üîé View Detailed Test Insight")

    # Dropdown to select test
    selected_test = st.selectbox(
        "Select a test case to view details:",
        merged["Test Name"].tolist(),
        index=0
    )

    # Fetch selected row
    test_row = merged[merged["Test Name"] == selected_test].iloc[0]

    # Dynamic explanation logic
    def get_test_description(name, layer):
        n = name.lower()
        if "login" in n:
            if "failure" in n:
                return "This test validates the system‚Äôs response to failed login attempts ‚Äî ensuring authentication rejects incorrect or missing credentials safely."
            elif "success" in n:
                return "This test verifies successful login flow using valid credentials and ensures user session is correctly established."
            elif "blank" in n or "missing" in n:
                return "Checks for proper error handling when username or password fields are missing or empty."
            elif "sql" in n:
                return "Ensures backend resilience against SQL injection attempts in login inputs."
            else:
                return "General login-related validation test ensuring authentication reliability."
        elif "moderate" in n:
            if "toxic" in n:
                return "Tests whether the content moderation engine correctly identifies toxic language."
            elif "clean" in n:
                return "Ensures safe or non-toxic text is accepted as clean."
            elif "empty" in n:
                return "Checks system behavior for empty or missing moderation text fields."
            else:
                return "General moderation API validation, ensuring accurate text toxicity detection."
        elif "protected" in n:
            if "expired" in n:
                return "Verifies that expired tokens are correctly rejected by secure endpoints."
            elif "invalid" in n:
                return "Ensures proper 401 Unauthorized responses for invalid tokens."
            elif "missing" in n:
                return "Checks that missing authorization headers are correctly handled."
            else:
                return "Tests general authorization validation logic for protected endpoints."
        elif "logout" in n:
            return "Validates logout process, ensuring user sessions are terminated properly and access tokens are invalidated."
        elif "ui" in n or "page" in n:
            return "Tests frontend UI behavior ‚Äî verifying visibility, navigation, and interaction consistency."
        else:
            return "General functional or integration test ensuring system reliability."

    # Display information
    st.markdown(f"### üßæ {test_row['Test Name']}")
    st.markdown(f"**Layer / Area:** {test_row['Layer / Area']}")
    st.markdown(f"**Status:** {test_row['Status']}")

    # Tools formatting with badges
    tools_html = "".join(
        f"<span style='background-color:#e6f7ff; color:#007acc; padding:3px 8px; border-radius:8px; margin-right:5px;'>‚úÖ {t.strip()}</span>"
        for t in test_row["Tools That Ran This Test"].split("‚úÖ ")
        if t.strip()
    )
    st.markdown(f"**Tools That Ran This Test:**<br>{tools_html}", unsafe_allow_html=True)

    # Dynamic description
    st.markdown("**Purpose / Usefulness:**")
    st.info(get_test_description(test_row['Test Name'], test_row['Layer / Area']))